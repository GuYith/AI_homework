Astar()
{
    open=[起始节点]；
    close=[];
    while(open表非空)
    {
        从open表中取f值最小的节点a，并从open表中删除；
        将a加入close表中；
        for(每一个a的可到达的合法节点b) /*不在close表中，且在地图内，与a相邻*/
        {
            if(b不在在open表中)  
            {；
                计算b的g值；
                计算b的h值
                计算b的f值；
                将a作为b的父节点；
                将b加入open表中；
            }
            if(b在open表中)
            {
                重新计算b的g值,记为g1；
                if(g1<g)
                {
                    更改b的g值；
                    更改b的父节点为当前节点a;
                    更改b的f值；
                }
            }
            if(b=目标节点)
            {
                输出路径；
                结束算法；
            }
        }
    }
}

BFS()
{
    open=[起始节点]；
    close=[];
    while(open表非空)
    {
        取open表的头节点a；
        将a加入close表中；
         for(每一个a的可到达的邻居节点b)
         {
             if(b合法)  /*即b不在close表中且不在open表中，在地图内*/
             {
                 将a作为b的父节点；
                 将b加入open表中；
             }
             if(b为目标节点)
             {
                 结束算法；
                 输出路径；
             }
         }
    }
}

updateMaze()
{
    将迷宫地图中各方格初始数据清零；
    生成初始地图；
    while(迷宫中存在节点无法到达的方格)
    {
        随机产生一个迷宫地图中的方格编号n；/*num为迷宫的行数  0<=n<=num*num-1*/
        产生于n相邻的任意节点m；
        if(方块n的根和方块m的根相同)/*即n,m在同一棵树上*/
        {            
            继续；
        }
        else
        {
            将n,m加入同一棵树；/*利用并查集算法，即置n,m两棵树中较小的那棵树加入大树中*/
            islink[n][m]=1;
            islink[m][n]=1;/*置n,m可以连通，即由n可到达m*/
            将n,m中间的墙去掉；
        }
    }
}


设置遍历次数time;
初始化食物信息素数组food；
初始终点(食物)的信息素为MAX;
标记的信息素浓度N
随时间消逝的信息素浓度M
antColony()
{

    初始化蚂蚁数组；
    将起点加入每只蚂蚁的路径中；
    while(time>=0)
    {
        
       //进行遍历每一只蚂蚁移动一步；
        for(每一只蚂蚁)//蚂蚁i
        {
            //从蚂蚁i从当前步数扩展下一步；
            将i可以到达的所有节点加入choose表；
            计算总的信息素浓度sum；
            if(sum!=0)
            {
                选择每个节点的概率=信息素浓度phre/sum；
                产生随机数choose;
                依据轮盘赌选择下一节点；
                记录蚂蚁经过该节点
            }
            else
            {
                随机选择choose表中的一个节点；
                记录蚂蚁经过该节点；
            }
            if(蚂蚁i找到食物)
            {
                if(当前蚂蚁i的tour的长度小于besttour)
                {
                    更新besttour为当前蚂蚁i的tour;
                }
                清空蚂蚁i的tour;
                将起点重新加入蚂蚁i的tour;
            }
        }
        //更新信息素,信息素初始为0，有蚂蚁在找到食物后才起作用
        {
            for(food每一个节点)
            {
                if(有蚂蚁经过)
                {
                    信息素浓度+N;
                }
                信息素浓度-M；            
            }
        }
        time--;
    }
    输出蚁群找到的最优路径；
}

